---
title: '常用排序算法'
date: 2014-09-18 18:29:23
category: 数据结构与算法
tags: sort C++
---

排序对于处理很多问题都可以提供一些便利，在日常生活中也常常进行排序（城市排名、大学排名、个人财富排名）等等。
对于排序算法，更是学习编程肯定会遇到的一种问题，常见的排序算法有：插入排序、冒泡排序、归并排序、堆排序、
希尔排序、快速排序等等等，十分丰富和强大。

### 插入排序

插入排序首先比较数组的前两个元素data[0]和data[1]，如有必要则进行交换，然后再取data[2]从0位置元素开始比较，找到其合适的位置，
此时将该位置及其后的元素都向后移动，把data[2]插入到位置，这就是插入排序名字的由来。其整个排序过程如图示：
<img src="http://7xrny8.com1.z0.glb.clouddn.com/blog/1457454286644.png" width="704"/>
如图示，原始数组如a所示，首先取数组的前两个元素1，4，正好是升序，不用交换位置(行b)，然后取第三个元素5，将从头开始与已有的前两个元素依次比较，
均大于他们，则5放置在第三个位置（如行c），然后取第四个元素2，从头依次比较，其大于1，小于4，则将其插入到4所在的位置，在插入之前，
需要将4、5两个元素分别向后移动一个位置（如行d），然后再取第五个元素7，从头依次比较，均大于前面的元素，则放置在第五个位置（如行e），
再取第六个元素3，从头依次比较后，放置在第三个位置，在插入之前，需要将后面的元素均向后移动一个位置（如行f），再取第七个元素6，从头依次比较，
发现其大于5小于7，则将7向后移动一个位置，将6插入在此位置（如行g），至此排序完成。该排序算法的伪代码如下：

``` cpp
insert_sorting()
    for 元素 in 数组
        从头依次比较，找到插入位置
        将该位置后的元素向后移动一个位置，插入该元素
```

该算法时间复杂度是O(n<sup>2</sup>)，最好情况是数组本来是有序的，则复杂度为O(n)

### 选择排序

选择排序的基本思路是：首先选择数组中的最小的元素，将其与第一个元素交换，然后选择除第一个元素外剩下元素的最小的元素，将其与第二个元素交换，
然后再选择剩余元素中最小的元素将其与第三个元素交换，以此进行下去，直到执行了n-1次即可停止，这时数组就排好序了，之所以不执行最后一次，
是因为当只剩下最后一个元素的时候，该元素必然是最大的元素，只能放在最后一个位置处。其整个过程如图示：
<img src="http://7xrny8.com1.z0.glb.clouddn.com/blog/1457454341854.png" width="675"/>

该排序算法的伪代码如下：
``` cpp
select_sorting()
    for i=0 到 n-2
        选择第i个之后剩余元素中最小的元素
        交换其与第i个元素
```

该算法的复杂度是O(n<sup>2</sup>)

### 冒泡排序

如果把一个数组想象成一个垂直的柱体，那么每一个元素当做一个气泡，对于每个气泡而言，如果气泡越轻，那么就会往上升，最轻的气泡在最顶，最重的气泡
则在最低端，这样的柱体中的气泡就都是有序排列的了。冒泡排序则是这样的一个实现过程，如图示：
<img src="http://7xrny8.com1.z0.glb.clouddn.com/blog/1457454520975.png" width="709"/>

如图示，首先比较底部的两个元素5和6，他们逆序，则交换他们的位置(如a->b)，然后比较之后的两个元素5和1，他们顺序ok，不用交换，接着再比较1和2，他们逆序，
交换这两个元素(如b->c)，再接着比较元素1和4，他们逆序，交换这两个元素(如c->d)，接着再比较1和3，他们仍然逆序，交换这两个元素(如d->e)，
至此所有元素都进行过了比较，此时最小的元素1已经排在顶部了，接下来继续从最底部的两个元素依次向上进行比较，直到比较到顶部第二个元素停止，
依次一直比较完，所有元素就完成排序了。
该算法伪代码如下：
``` cpp
bubble_sorting()
    for i=0 到 n-1
        for j=n-1 到 i
            如果j 和j-1 逆序则交换他们
```

该算法的复杂度仍然为O(n<sup>2<sup>)

### 希尔排序

前述的基本排序算法的复杂度都达到了O(n<sup>2</sup>)，显然太大，因此必须打破这个限制，改善算法效率。从上面的基本排序算法我们可以知道随着序列长度N的增加，
算法的时间会增长得更快，同时对于已经是有序的序列进行排序的时候可以明显减少比较或者交换元素位置的次数，基于这两种情况，我们可以想象如果
将一个很长的序列分成短一些的多个子序列，对每个子序列进行排序（序列较短，时间消耗相对少），然后再将整个序列进行排序（子序列都是相对有序的，时间消耗相对少），
基于这一思想的一种算法称为希尔(Shell)排序。

希尔排序的核心的将序列巧妙的分组成为几个子数组，例如将数组分为h个子数组，那么每个子数组的元素分别为data[h\*i+0],data[h\*i+1],data[h\*i+2]..然后对每个子数组进行排序，
对字数组的排序通常就选择基本的排序算法，常见的是选择插入排序算法。完整的希尔排序是进行多轮的子数组切分：
h<sub>1</sub>，h<sub>2</sub>...h<sub>i</sub>，h<sub>1</sub>为1，即最后一次排序是对所有的元素进行排序。
h<sub>i</sub>之间通常满足关系 h<sub>1</sub> = 1; h<sub>i+1</sub> = h<sub>i</sub> * 3 + 1;
取h分别为5、3、1时，对数组[6,3,5,7,9,10,2,1,4,8]的一次排序过程如图示：
<img src="http://7xrny8.com1.z0.glb.clouddn.com/blog/1457454552849.png" width="729"/>

当h=5时，将元数组分成了5个子数组，第一个子数组为[6,10],对其排序，第二个子数组为[3，2]，对其排序，依次完成5个子数组的排序后如图中h=5那行，然后取h=3，将数组分成3个子数组，
第一个子数组为[6,4,3,9],对其进行排序，第二个子数组为[2,8,5],对其进行排序，第三个子数组为[1,10,7],对其进行排序，完成之后如图中h=3那行，最后h=1，
对数组进行排序。广泛的经验性研究表明，希尔排序的时间复杂度为O(nlgn)。

### 堆排序

我们知道选择排序要执行O(n<sup>2</sup>)次比较，效率很低，尤其是n很大的情况，但是它也有一个有点就是执行较少次数的数据移动操作。如果对选择排序算法的选择部分做
一些改进，那么很有希望能提高算法效率。堆排序就是基于这一思想而形成的算法，他选择元素中最大的元素将其放置的数组最尾端，然后选择次大的元素将其放置到数组最尾端的前一个位置，
依次进行下去，则可以将数组按升序排列。堆排序使用了堆这种数据结构，堆具有以下2个特点：

* 每个节点都不会小于其子节点
* 树是一个完全平衡树(任何节点的子树高度差都是0或1，所有叶子节点都出现在一个或两个层次上)，最低层的叶子节点都位于左边位置

根据堆的第一个性质，我们可以在排序的时候每次都取堆的根节点放置于已排序的数组部分，并把堆的最后一个节点放置在堆的根节点的位置，从堆中删除最后一个节点位置，
然后将其下移，恢复堆的性质，依次进行则可以完成排序。因此堆排序可以分为两个步骤，第一步先将数组构建成一个堆，构建堆的方法可以使用自底向顶的方式，伪代码如下：

``` cpp
for 最后一个非叶子节点 到 根节点
    p = 该节点
    while p不是叶子节点，并且p 小于其中一个子节点
        将p与较大的子节点交换
```

第二步对堆进行排序操作，每次都选择根节点，与最后一个节点交换，然后从堆中去除最后一个子节点，将根节点下移，恢复堆的性质，伪代码如下：

``` cpp
for 根节点
    根节点与堆的最后一个节点互换
    堆数组的长度减一
    p = 根节点
    while p不是叶子节点，并且p 小于其中一个子节点
        将p 与较大的子节点交换
```

堆排序的复杂度为O(nlgn)

### 快速排序

在前面简介希尔排序的时候，一个基本的思想是不断的对数组进行切分，仅对每个子数组进行排序，基于这种思想C.A.R.Hoare也发明了一种算法，
称为快速排序。快速排序的基本流程是选择一个数组中的值作为阈值，小于该值的所有元素组成一个子数组，大于该值的作为另一个子数组，划分完之后
再对两个子数组做同样的处理，直到子数组只包含一个元素时，那么该数组就完成好了排序。快速排序思想本身是递归的，那么该算法的实现使用递归也十分容易实现。
一种简单的实现伪代码如下：
``` cpp
quicksort(array)
    if array长度大于1
        选择一个元素作为阈值
        while array中的元素
            if 大于阈值
                该元素划到子数组1
            if 小于阈值
                该元素划到子数组2
        quicksort 子数组1
        quicksort 子数组2
```

伪代码所描述的实现方式需要额外的空间来存储子数组，因此的真正的实现过程中，都是直接在原数组中进行元素的移动来完成，如果每次都去数组的第一个元素作为阈值，
一个快速排序的流程如图：
<img src="http://7xrny8.com1.z0.glb.clouddn.com/blog/1457454581498.png" width="782"/>

如图对数组[7,2,9,3,8,4]进行排序，首先选择第一个元素作为阈值，lower和upper指针分别指向数组的始端和尾端，然后从upper指向的元素与阈值做比较，其为4，小于阈值
需要放在子数组1中，因此与lower指向的元素进行交换，交换之后lower指针自增1，然后取lower指向的元素2与阈值比较，其小于阈值，不用交换，lower加1，然后取9与阈值比较，
其大于阈值，应该放在子数组2中，因此与upper指向的元素交换，交换之后upper自减1，然后再去upper指向的元素8与阈值比较，大于阈值，不用交换，upper减1，取3与阈值比较，
小于阈值，与lower指向的元素交换，lower加1，此时lower与upper相等，说明所有的元素均与阈值进行过一次比较，结束循环，将阈值赋值给upper指向的元素，然后再对两个字数组
进行同样的操作。

快速排序算法的时间复杂度是O(nlgn)，在最坏情况下的算法复杂度为O(n<sup>2</sup>)。

### 归并排序

在介绍快速排序的时候，其选择阈值的是比较麻烦的，因为阈值的选择关系到是否能将数组均匀的分成两个子数组，子数组的长度差距越大，需要切分子数组的次数就越多，那复杂度就相对的更大。

为了解决子数组的切分问题，有一种叫做归并排序的算法，归并排序很好的归并了子数组切分的问题，它每次都将数组从数组的中间分成两个子数组，在对子数组进行合并的过程中来实现对数组的排序。以下伪代码表示了归并排序的过程：

``` cpp
mergesort
    if 数组包含两个或以上元素
        mergesort（数组的左半部分）
        mergesort（数组的有半部分）
        merge两个子数组
```

两个子数组的合并过程可以用下面的伪代码表示：

``` cpp
merge
    while 两个子数组中都还有元素
        if subarray1 > subarray2
            temparray[i++] = subarray2
        else
            temparray[i++] = subarray1
```

由上可以看出在合并需要额外的空间来临时存储合并好的数组，有个额外的空间占用。

### 基数排序

基数排序是日常生活中用得很多的一种排序方法，例如英文词典中单词的排列首先按照单词的首字母进行区分，所有A字母开头的单词均排在一起，B开头的单词排在一起，对于同是A字母开头的单词则安装第二个字母用同样的方法进行排序，这种排序方法称为基数排序。
对于整数的基数排序有两种基本的方式，一种是按照整数字符从末位开始排序，然后排序次末位，依次进行，直到排序完成，另一种是按照整数的二进制位来进行排序。

如图是一个简单的按照整数字符对数组 [12,32,122,4,53,345,21,3] 进行基数排序的过程：
<img src="http://7xrny8.com1.z0.glb.clouddn.com/blog/1457454607794.png" width="769"/>

首先按照每个元素的第一位字符进行分堆，相同字符的处于同一堆，每个堆都是一个对列，然后按照每个堆的顺序输出得到如图‘第一位’后的结果[21,12,32,122,53,3,4,345]，
然后对该数组按照第二个字符进行再次分堆，没有第二位字符的整数按照该位为0处理，然后按照堆的顺序以队列的方式输出得到‘第二位’后的结果[3,4,12,21,122,32,345,53],
再按照上面的方式对第三位字符进行分堆，当所有元素都处于同一堆时则结束分堆，此时数组也就成为了有序数组。

基数排序的复杂度是线性的为O(dn)，d为分堆时进行的次数。


___参考：《数据结构与算法----C++版(第三版)》，清华大学出版社___




