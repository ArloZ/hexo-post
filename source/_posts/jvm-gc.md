---
title: Java虚拟机--内存管理
tags: []
date: 2016-04-10 23:17:04
categories:
---

最近在阅读<深入理解Java虚拟机-Java高级特性与最佳实践>一书，对一些概要性的东西做一下记录，也算是一个简单的读书笔记吧。

<!--more-->

# Java 内存管理机制

## Java运行时数据区域

#### 程序计数器
>线程独享，存储当前线程执行的字节码行号

#### 虚拟机方法栈
>线程独享，生命周期与线程相同，用于存储java方法执行时的局部变量表（基本数据类型、对象引用类型、returnAddress类型）、动态链接、方法出口等
> -Xss设置虚拟机栈的大小

#### 本地方法栈
>线程独享，与虚拟机栈类似，存储的是本地方法执行时的相关数据
> -Xoss设置本地方法栈的大小

#### 堆
>各个线程共享，用于存储对象实例
> -Xms、-Xmx虚拟机的堆内存大小参数

#### 方法区
>各个线程共享，用于存储类信息、常量、静态变量、即时编译器编译后的代码
* 运行时常量池：是方法区的一个部分

#### 直接内存
>并不属于Java运行时数据区的一部分，可以通过native函数直接分配内存

## Java对象的访问
示例：
```
Object obj = new Object();
```
上面的语句将会涉及到java运行时数据区中的：堆、java方法栈、方法区三个区域。`Object obj`将会是java方法栈中的一个对象引用类型的数据，`new Object()`将会生成一个对象实例存储在堆中，方法去存储了`Object`类的类型信息。


## Java的垃圾回收机制

#### 垃圾回收算法
* 引用计数法：java并不是使用该方法，通过Demo可以看出，虽然A、B互相引用，但是仍然可以进行垃圾回收
* 跟搜索算法：从`GC Root`向下搜索，对象不可达则证明此对象可以被回收，以下可作为`GC Root`：
    * 虚拟机栈中的引用的对象
    * 方法区中静态类属性引用的对象
    * 方法去中常量引用的对象
    * 本地方法栈JNI中引用的对象

#### 引用概念的细分
* 强引用：具有强引用的对象不会被GC回收
* 软引用：用于描述有用但不一定必须存在的对象，当内存不足时才会进行二次回收将软引用的对象进行回收
* 弱引用：比软引用关系更弱的一种引用，可以生成到下一次GC之前，无论内存是否足够，GC都会回收该引用的对象
* 虚引用：最弱的一种引用关系，不影响垃圾回收，存在的意义仅是为了能够在垃圾回收时收到系统通知

#### 对象的生存or死亡
根搜索算法对于不可达对象会进行两次标记，以判定该对象是否正在的成为`死亡`对象,当根搜索算法发现不可达对象时，会进行第一次标记，并决定是否调用该对象的`finalize`方法，如果该对象没有覆写`finalize`方法或者已经执行过了，则不会触发`finalize`方法了，否则将其加入到单独的Finalizer线程中等待执行。如果对象在`finalize`方法中将自己作为了某个对象的引用，则可以避免下次被GC，逃脱死亡命运。
稍后GC对象Finalizer线程中的对象进行第二次标记，如果对象被引用，则移除待回收集合，否则被GC回收。

```
public class App {

    public static App hook = null;

    private byte[] big = new byte[20 * 1024 * 1024];

    public void isAlive() {
        System.out.println("I am alive..");
    }

    @Override
    protected void finalize() throws Throwable {
        super.finalize();
        System.out.println("finalize execute...");

        hook = this;
    }

    public static void main(String[] args) throws Throwable {
        App app = new App();

        app = null;
        hook = null;
        System.gc();
        Thread.sleep(500);
        if (hook != null) {
            hook.isAlive();
        } else {
            System.out.println("Ok dead...");
        }

        hook = null;
        System.gc();
        Thread.sleep(500);
        if (hook != null) {
            hook.isAlive();
        } else {
            System.out.println("Ok dead...");
        }
    }
}

##### OUTPUT
[Full GC (System) [CMS: 20480K->20908K(63872K), 0.0125255 secs] 22531K->20908K(83008K), [CMS Perm : 4893K->4891K(21248K)], 0.0126288 secs] [Times: user=0.01 sys=0.00, real=0.01 secs] 
finalize execute...
I am alive..
[Full GC (System) [CMS: 20908K->417K(63872K), 0.0178282 secs] 21589K->417K(83008K), [CMS Perm : 4908K->4908K(21248K)], 0.0179047 secs] [Times: user=0.01 sys=0.00, real=0.01 secs] 
Ok dead...
```

从上面Demo的输入可以看出，第二次才进行了正在的GC：`21589K->417K`

#### 方法区的GC
>通常GC都是对堆内存区进行的，而很少从方法区进行GC（因为性价比比较低），堆内存区一次GC通常可以回收70%的空间

方法区(又叫永久代)进行GC回收的主要两部分内容：废弃常量和无用的类

* 回收废弃常量的方法与堆中回收对象类似
* 回收无用的类需要满足以下条件：
    * 该类的所有实例已被回收
    * 加载该类的ClassLoader已被回收
    * 该类对应的Class对象没有被引用，处于可回收状态，即没有在任何地方通过反射访问该类的方法

#### 垃圾收集算法简析
* 标记-清除算法
> 通过对需要回收的对象进行标记，完成一轮标记之后进行一轮清楚，这种方法的缺点是会存在内存碎片，导致大量的不连续内存，这样在下次进行内存分配的时候遇到分配大块的内存则需要再次进行内存的回收
* 复制算法
> 为了解决`标记-清除算法`的效率问题，复制算法将内存分为两块区域，每次仅适用其中一块内存区域，当一块内存区域快要用完时，则将还存活的对象copy到另外一块保留区域，并清空当前内存区域，然后适用新的内存区域，但是这样会使得内存空间仅有可使用空间的50%
* 标记整理算法
> 针对标记清理算法，标记过程与其相同，而是把清理的过程变成了重新整理存活的对象，然后清除边界以外的剩余内存。
* 分代收集算法
> 通常是将java堆分为新生代和老年代两个内存区域，然后根据新生代和老年代的对象特点使用不同的垃圾收集算法，对于新生代，由于对象存活率低，可以采用复制算法，对于老年代，对象存活率高，可以使用标记清理或标记整理算法。
> 新生代和老年代：对象创建时都是在新生代(一些大对象的创建直接在老年代中)，在每经历一次新生代的收集后对象的`年龄`将会+1，如果对象的年龄达到某个阈值(通常是是15岁)那么该对象将会被移入老年代区域。新生代的GC比老年代的GC频繁很多，通常新生代的GC称为：`Minor GC`，老年代的GC称为：`Full GC/Major GC`

#### 垃圾收集器
> 垃圾收集算法是垃圾回收的方法论，那垃圾收集器就是垃圾回收的具体实现

* Serial收集器 -- 新生代收集器
> 是最古老和历史悠久的收集器，它是一个单线程的收集器，当进行GC的时候将暂停所有的用户线程。Serial收集器对于新生代的对象使用复制算法进行收集，而Serial Old收集器对老年代的收集算法采用`标记-清除算法`。目前在Client模式下仍然是JVM默认的新生代收集器。

* ParNew收集器 -- 新生代收集器
> 是Serial收集器的多线程版本，在进行收集时暂停所有用户线程，然后自身进行多线程操作进行垃圾收集。所采用的收集算法、控制参数、Stop the world、对象分配规则、回收策略都与Serial收集器相同，是在Server模式下的JVM的首选。除Serial外只有它能和CMS收集器配合工作。

* Parallel Scavenge收集器 -- 新生代收集器
> 也是一个并行处理的新生代收集器，采用复制算法，看起来和ParNew收集器相同，但是它的目标是达到一个可控制的吞吐量(吞吐量 = 用户程序执行时间/(用户程序执行时间+垃圾收集占用时间))， `-XX:GCTimeRatio`参数可以直接设置吞吐量。它可以具有自动调整策略，当设定了一个吞吐量目标之后，如果不设置新生代大小、Survivor比例、晋升老年代对象年龄等细节参数，那么虚拟机将会根据系统的允许状况和监控信息进行自动的优化调整。这也是与ParNew收集器一个重要区别。

* Serial Old收集器 -- 老年代收集器
> 它是Serial收集器的老年代版本，同样是一个单线程收集器，会暂定所有用户线程，采用`标记-整理算法`，其也是主要用于client模式下的虚拟机。

* Parallel Old收集器 -- 老年代收集器
> Parallel Scavenge收集器的老年代版本，采用多线程和`标记-整理算法`。在注重吞吐量的场合，采用`Parallel Scavenge`和`Parallel Old`收集器组合通常能够达到很好的效果

* CMS(Concurrent Mark Sweep)收集器 -- 老年代收集器
> 它是一种以获取最短停顿时间为目标的收集器，非常符合需要快速响应的应用场合，基于`标记-清除算法`。
> 它的运行过程相对其他的老年代收集器要稍微复杂点，一共需要经历以下4个步骤
>   * 初始标记
>   * 并发标记
>   * 重新标记
>   * 并发清除
>
> 其中初始标记和重新标记都遵循`Stop The world`原则。
> 它的优点是并发收集、低停顿，但是也存在比较明显的缺点：
>   * CMS收集器对CPU资源和敏感，并发阶段会占用CPU资源导致用户线程的响应时间变长。
>   * CMS收集器无法处理浮动垃圾`Floating Garbage`，可能出现`Concurrent Mode Failure`失败，而导致使用备用的Serial Old方案再次进行GC，这样GC耗时就大大增加了。出现`Concurrent Mode Failure`失败的原因是CMS在进行垃圾回收的时候由于用户线程还在继续运行，那么需要预留一部分空间，当预留的空间不能满足用户线程运行时内存分配时则会出现该失败。
>   * CMS收集器是基于`标记-清除算法`的，这样在进行一次GC后会有内存碎片，当碎片过多时将会对大对象的内存分配造成困难。提供了参数可以设定在进行GC之后进行一次内存整理，或者在进行多次GC后进行一次内存整理。

* G1(Garbage First)收集器 -- 新、老年代收集器
> 在CMS收集器的基础上，采用`标记-整理算法`避免产生内存碎片，另外他将整个java堆(新生代和老年代)分为多个区域，后台维护一个优先列表，然后根据设定的允许收集时间，优先收集垃圾堆积最多的区域(这就是Garbage First名字的由来)。

#### 内存分配和回收策略
* 对象优先在Eden分配
* 大对象之间进入老年代
* 长期存活的对象将进入老年代，默认年龄为15
* 动态对象年龄判断，当对象某年龄未达到阈值，但同年龄对象空间占用总和大于Survivor空间的一半时，年龄大于等于该值的都之间进入老年代
* 空间分配担保







