---
title: Java虚拟机--编译与优化
tags: [java,optimize,compile]
date: 2016-05-01 10:32:20
categories: java

---

最近在阅读<深入理解Java虚拟机-Java高级特性与最佳实践>一书，对一些概要性的东西做一下记录，也算是一个简单的读书笔记吧，本篇问主要是记录一下程序编译与代码优化和高效并发。

<!--more-->

# 编译期优化

### Javac编译器

##### 解析与填充符号表

* 词法、语法分析
* 填充符号表

##### 注解处理器

##### 语义分析和字节码生成

语义分析是在语法分析完成后，对抽象语法树进行正确性分析，如类型转换等是否合法。

### Java语法糖

* 泛型与类型擦除
* 自动装箱、自动拆箱、遍历循环

# 运行时优化

### HotSpot虚拟机中的JIT编译器

##### 解释器和编译器

常用的商用虚拟机都采用了解释器+编译器的架构，可以在启动时通过解释器来执行代码，或得更快的启动速度，随着程序的执行，编译器编译为本地机器码的代码越来越多，获得更高的执行效率。在HotSpot虚拟机中，存在两个编译器：Client Compiler、Server Compiler（C1，C2）

##### 编译对象和触发条件

即时编译的对象主要包括：被多次调用的方法、被多次执行的循环体。当方法或循环体的调用次数超过一个阈值之后，将会触发即时编译，再次执行时就直接执行编译后的机器代码。

##### 编译过程

C1、C2编译器的编译过程是不一样的

![C1编译过程](http://7xrny8.com1.z0.glb.clouddn.com/blog/1462077305601.png)

C2编译器将会进行更多的优化操作，已达到更高的执行效率，随之而来的是C2编译器的编译过程耗时更长。

##### 查看和分析即时编译结果

### 编译优化技术

* 公共子表达式消除
* 数组边界检查消除
* 方法内联
* 逃逸分析

# Java与C/C++编译器对比



# Java内存模型与线程

### Java内存模型（JMM）

Java内存模型的主要目标是定义Java中变量的访问规则，模型规定了Java变量都存储在主内存中，每条线程还有自己的工作内存，工作内存中存储了该线程的变量在主内存中的副本，线程对变量的操作都必须是对工作内存的操作，不能直接对主内存进行操作。线程间变量的共享通过主内存实现。

![](http://7xrny8.com1.z0.glb.clouddn.com/blog/1462109033753.png)

Java虚拟机的内存模型定义了以下8中内存简单操作：

* `lock`线程锁定一个主内存变量，执行lock操作后将会清空该变量在工作内存的值
* `unlock`线程解锁一个主内存变量，执行unlock前必须将工作内存的该变量写回主内存
* `read`从主内存读取到工作内存
* `load`将read操作的变量值放入工作内存的副本中
* `use`从工作内存中获取变量到执行引擎
* `assign`将执行引擎中得到的值赋值到工作内存的变量
* `store`将工作内存的变量传递到主内存
* `write`将store操作的变量存入主内存

##### volatile变量的特殊访问规则

volatile变量具备两种特性：一是内存模型保证此变量对所有线程的`可见性`，即一个线程修改了该变量值，那么所有线程都可见。二是volatile变量禁止指令重排优化，即保证变量的定义与赋值操作之间的指令执行顺序不被重排优化，但是定义前后的指令仍然可以进行重排优化的。

内存模型对volatile变量的特殊规则：

* use操作必须和load操作同时出现，执行use之前必须进行load，以获取主内存中的最新值，assign操作必须和store操作同时出现，执行assign之后必须进行store，以保证主内存是最新值。
* 对变量的操作指令不可进行重排

##### long和double变量的特殊访问规则

非原子性协定：虚拟机规范允许对long和double这两个64位的变量操作：read、load、store、write4个操作不保证原子性，这就有可能导致线程读取到的非volatile修饰的long、double有可能只有半个变量。但是目前商用的虚拟机都把long、double变量的操作实现为原子操作。

##### 原子性、可见性、有序性

* 原子性：java中对变量的6个操作read、load、use、assign、store、write都保证了原子性（long、double变量的非原子协议），lock和unlock两个指令可以用来实现操作的原子性。代码中的synchronized语句块可以实现操作的原子性
* 可见性：一个线程修改了共享变量的值之后，其他线程能够立即知道这个修改。
* 有序性：

##### 先行发生原则

操作A先行发生于操作B，那么操作A的影响可以被操作B观察到，包括共享内存变量值、消息、方法调用。

### java与线程

##### 线程的实现

##### java线程调度

SunJDK的java虚拟机的线程模型采用的一对一线程模型，即将java线程映射为操作系统内核线程（轻量级进程），线程的调用也通过系统调度进行。java线程存在10个优先级，但是不太靠谱，不能与系统的执行优先级对应，有可能被系统调整线程执行的优先级。

##### 状态转换

* 新建状态
* 运行状态
* 无限期等待状态
* 限期等待状态
* 阻塞状态
* 结束状态

![](http://7xrny8.com1.z0.glb.clouddn.com/blog/1462185675684.png)

# 线程安全与锁优化



